<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Atlas - Architect</title>
    <style>
        :root { --bg: #050505; --panel: #111; --accent: #00d2ff; --text: #ddd; --danger: #ff4444; --success: #00ff88; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; user-select: none; }

        /* HEADER */
        header { height: 45px; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; background: #080808; border-bottom: 1px solid #333; }
        #back-btn { background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding-right: 15px;}
        .mode-tabs { display: flex; gap: 8px; }
        .tab-btn { background: #222; border: 1px solid #444; color: #888; padding: 6px 14px; cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 11px; letter-spacing: 0.5px;}
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
        .action-btn { background: #333; color: white; border: 1px solid #555; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold; }
        .action-btn:hover { background: #555; }

        /* VIEWPORT */
        #viewport { display: flex; height: calc(100vh - 205px); width: 100%; position: relative; }
        .canvas-container { flex: 1; position: relative; border-right: 1px solid #333; overflow: hidden; background: #000; }
        
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        
        /* The CPU renderer overlays the GPU renderer */
        .cvs-cpu { z-index: 5; opacity: 0; pointer-events: none; transition: opacity 0.2s;} 
        
        .view-label { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 10;}

        /* OVERLAYS */
        #bottom-bar { position: absolute; bottom: 170px; left: 10px; pointer-events: none; display: flex; gap: 10px; z-index: 10; align-items: center;}
        .info-tag { background: rgba(0,0,0,0.8); padding: 6px 12px; font-size: 12px; border: 1px solid #444; border-radius: 4px; pointer-events: auto; font-family: monospace;}
        #lock-indicator { display: none; color: var(--success); border-color: var(--success); font-weight: bold; background: rgba(0,255,136,0.1);}
        #zoom-warning { display: none; color: var(--danger); border-color: var(--danger); font-weight: bold; background: rgba(255,0,0,0.1);}

        /* CONTROLS */
        #controls { height: 160px; background: #080808; border-top: 1px solid #333; padding: 10px 15px; overflow-y: auto; }
        .ctrl-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 15px; align-items: start; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 10px; color: #aaa; text-transform: uppercase; font-weight: bold; }
        
        input[type="range"] { width: 100%; height: 6px; background: #333; appearance: none; border-radius: 3px; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; }
        select, input[type="text"], input[type="number"] { background: #222; color: #eee; border: 1px solid #444; padding: 6px; border-radius: 4px; font-size: 12px; width: 100%; cursor: pointer;}
        
        .val-disp { font-size: 10px; color: var(--accent); float: right; }
        .lbl-r { color: #ff6b6b; } .lbl-g { color: #51cf66; } .lbl-b { color: #339af0; }
        .hidden { display: none !important; }

        /* SAVE MODAL */
        #save-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; align-items: center; justify-content: center; }
        .modal-box { background: #151515; border: 1px solid #444; padding: 25px; width: 320px; border-radius: 8px; }
        .modal-row { margin-bottom: 15px; }
    </style>
</head>
<body id="app-body">

<header>
    <button id="back-btn" onclick="window.parent.goBack()">&#8592;</button>
    <div class="mode-tabs">
        <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
        <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
        <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
    </div>
    <div style="flex:1"></div>
    <button class="action-btn" onclick="ui.toggleModal(true)">SAVE VIEW</button>
</header>

<div id="viewport">
    <div class="canvas-container">
        <div class="view-label" id="lbl-left">Mandelbrot</div>
        <!-- Dual Canvas Architecture -->
        <canvas id="gl-left"></canvas>
        <canvas id="cpu-left" class="cvs-cpu"></canvas>
    </div>
    <div class="canvas-container">
        <div class="view-label" id="lbl-right">Julia Set</div>
        <canvas id="gl-right"></canvas>
        <canvas id="cpu-right" class="cvs-cpu"></canvas>
    </div>
</div>

<div id="bottom-bar">
    <div class="info-tag" id="c-coords">C: -0.7600, 0.1200</div>
    <div class="info-tag" id="lock-indicator" title="Double click canvas to unlock">üîí SEED LOCKED</div>
    <div class="info-tag" id="zoom-warning">‚ö†Ô∏è HARDWARE LIMIT: GPU Float32 rounding causing pixelation.</div>
</div>

<div id="controls">
    <div class="ctrl-grid">
        
        <div class="control-group">
            <label>Fractal Equation</label>
            <select id="sel-eq" onchange="app.triggerReset()">
                <option value="0">Mandelbrot (z¬≤ + c)</option>
                <option value="1">Cubic (z¬≥ + c)</option>
                <option value="2">Quintic (z‚Åµ + c)</option>
                <option value="3">Burning Ship</option>
                <option value="4">Tricorn</option>
            </select>
        </div>

        <div class="control-group">
            <label>Max Iterations <span id="val-iter" class="val-disp">300</span></label>
            <input type="range" id="sl-iter" min="50" max="10000" value="300">
        </div>

        <div class="control-group">
            <label>Zoom Speed (Scroll)</label>
            <input type="range" id="sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <!-- Nebula Only -->
        <div class="control-group hidden" id="grp-neb-r">
            <label class="lbl-r">Red Threshold <span id="val-red" class="val-disp">200</span></label>
            <input type="range" id="sl-red" min="0" max="1000" value="200">
        </div>
        <div class="control-group hidden" id="grp-neb-g">
            <label class="lbl-g">Green Threshold <span id="val-grn" class="val-disp">100</span></label>
            <input type="range" id="sl-grn" min="0" max="1000" value="100">
        </div>
        <div class="control-group hidden" id="grp-neb-b">
            <label class="lbl-b">Blue Threshold <span id="val-blu" class="val-disp">50</span></label>
            <input type="range" id="sl-blu" min="0" max="1000" value="50">
        </div>
        <div class="control-group hidden" id="grp-neb-den">
            <label>Nebula Brightness</label>
            <input type="range" id="sl-den" min="0.1" max="5.0" step="0.1" value="1.5">
        </div>

        <!-- Standard Only -->
        <div class="control-group" id="grp-pal">
            <label>Color Palette</label>
            <select id="sel-pal" onchange="app.triggerReset()">
                <option value="0">Magma</option>
                <option value="1">Viridis</option>
                <option value="2">Ice</option>
                <option value="3">Electric</option>
            </select>
        </div>

        <!-- Atlas Only -->
        <div class="control-group hidden" id="grp-grid">
            <label>Atlas Grid Size <span id="val-grid" class="val-disp">10</span></label>
            <input type="range" id="sl-grid" min="2" max="100" value="10">
        </div>

        <div class="control-group">
            <label>&nbsp;</label>
            <button class="action-btn" style="width:100%" onclick="app.resetPos()">RESET POSITION</button>
        </div>
    </div>
</div>

<!-- SAVE MODAL -->
<div id="save-modal">
    <div class="modal-box">
        <h3 style="margin-top:0; color:white;">Save High-Res Render</h3>
        <div class="modal-row">
            <label style="display:block; margin-bottom:5px; color:#aaa; font-size:10px;">TARGET WINDOW</label>
            <select id="save-view">
                <option value="left">Left Window</option>
                <option value="right" selected>Right Window</option>
            </select>
        </div>
        <div class="modal-row" id="row-res">
            <label style="display:block; margin-bottom:5px; color:#aaa; font-size:10px;">RESOLUTION</label>
            <select id="save-res" onchange="ui.checkCustomRes()">
                <option value="1">Screen Size (Fast)</option>
                <option value="2">HD (1920x1080)</option>
                <option value="4">4K (3840x2160)</option>
                <option value="custom">Custom Keyboard Input...</option>
            </select>
            
            <div id="custom-res-div" style="display:none; margin-top:10px; gap:10px; align-items:center;">
                <input type="number" id="save-w" value="1920" style="width:80px;" placeholder="Width"> x 
                <input type="number" id="save-h" value="1080" style="width:80px;" placeholder="Height">
            </div>
            
            <div style="font-size: 10px; color: var(--accent); margin-top: 10px;">Note: Nebulae are saved natively from the progressive engine to preserve trajectory detail.</div>
        </div>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
            <button class="action-btn" onclick="ui.toggleModal(false)">Cancel</button>
            <button class="action-btn" style="background:var(--accent); color:black;" onclick="app.save()">Download Image</button>
        </div>
    </div>
</div>

<script>
// =======================================================
// MODULE 1: WEBGL RENDERER (For Standard Fractals)
// =======================================================
const GL_CORE = {
    setup: function(canvasId) {
        const cvs = document.getElementById(canvasId);
        const gl = cvs.getContext('webgl', {preserveDrawingBuffer:true});
        
        const vs = `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`;
        const fs = `
            #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
            #else
            precision mediump float;
            #endif
            
            uniform vec2 u_res; uniform vec2 u_offset; uniform float u_zoom; uniform vec2 u_c;
            uniform int u_mode; uniform int u_view; uniform float u_iter; uniform float u_grid;
            uniform int u_pal; uniform int u_eq;

            vec3 palette(float t, int id) {
                vec3 a=vec3(0.5), b=vec3(0.5), c=vec3(1.0), d;
                if(id==0) d=vec3(0.3,0.2,0.2);
                else if(id==1) d=vec3(0.0,0.33,0.67);
                else if(id==2) { c=vec3(0.8); d=vec3(0.15,0.2,0.3); }
                else { c=vec3(2.0); d=vec3(0.5,0.2,0.25); }
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
                vec2 z, c;
                bool isAtlas = (u_mode == 2);
                
                if(isAtlas) {
                    vec2 guv = uv * u_grid;
                    vec2 cell = floor(guv);
                    vec2 tile = fract(guv) - 0.5;
                    float rng = 4.0 / u_zoom;
                    z = tile * 3.0;
                    c = u_offset + (cell / u_grid) * rng;
                } else {
                    vec2 p = uv / u_zoom + u_offset;
                    if(u_view == 1) { z = p; c = u_c; } else { z = vec2(0.0); c = p; }
                }

                float iter = 0.0; float m = 0.0;
                
                for(int i=0; i<10000; i++) {
                    if(float(i) > u_iter) break;
                    
                    if(u_eq == 0) z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c; 
                    else if(u_eq == 1) z = vec2(z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y) + c; 
                    else if(u_eq == 2) {
                        float r2=z.x*z.x+z.y*z.y; float r4=r2*r2; float r5=r4*sqrt(r2);
                        float a=atan(z.y,z.x)*5.0; z = r5*vec2(cos(a),sin(a)) + c; 
                    }
                    else if(u_eq == 3) z = vec2(z.x*z.x - z.y*z.y, 2.0*abs(z.x*z.y)) + c; 
                    else if(u_eq == 4) z = vec2(z.x*z.x - z.y*z.y, -2.0*z.x*z.y) + c; 
                    
                    m = dot(z,z);
                    if(m > 100.0) break;
                    iter += 1.0;
                }

                vec3 col = vec3(0.0);
                if(m >= 100.0) {
                    float sn = iter - log2(log2(m)) + 4.0;
                    col = palette(sn * 0.03, u_pal);
                }

                // Grid & Dot Overlays (SCREEN SPACE)
                if(isAtlas) {
                    vec2 guv = abs(fract(gl_FragCoord.xy/u_res.y * u_grid) - 0.5);
                    if(guv.x>0.48 || guv.y>0.48) col *= 0.5;
                } else if(u_view == 0) {
                     vec2 screen_c = (u_c - u_offset) * u_zoom;
                     float dist = distance(uv, screen_c);
                     if(dist < 0.012) col = vec3(1.0);
                     else if(dist < 0.016) col = vec3(0.0);
                }

                gl_FragColor = vec4(col, 1.0);
            }
        `;
        
        const prog = gl.createProgram();
        const vsh = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vsh, vs); gl.compileShader(vsh);
        const fsh = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fsh, fs); gl.compileShader(fsh);
        gl.attachShader(prog, vsh); gl.attachShader(prog, fsh); gl.linkProgram(prog);
        
        const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const loc = gl.getAttribLocation(prog, 'p');
        gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

        return { gl, cvs, prog };
    },

    render: function(ctx, state, isRight) {
        const {gl, cvs, prog} = ctx;
        const dpr = window.devicePixelRatio || 1;
        
        if(!state.saving) {
            const w = Math.floor(cvs.clientWidth * dpr);
            const h = Math.floor(cvs.clientHeight * dpr);
            if(cvs.width !== w || cvs.height !== h) { cvs.width = w; cvs.height = h; gl.viewport(0,0,w,h); }
        }

        gl.useProgram(prog);
        const u = (n,v) => { const l=gl.getUniformLocation(prog,n); if(typeof v==='number')gl.uniform1f(l,v); else gl.uniform2f(l,v[0],v[1]); };
        const ui = (n,v) => gl.uniform1i(gl.getUniformLocation(prog,n),v);

        const cam = isRight ? state.right : state.left;
        u('u_res', [cvs.width, cvs.height]);
        u('u_offset', [cam.x, cam.y]); u('u_zoom', cam.z); u('u_c', [state.c.x, state.c.y]);
        u('u_iter', state.p.iter); u('u_grid', state.p.grid);
        ui('u_mode', state.mode); ui('u_view', isRight?1:0); ui('u_pal', state.p.pal); ui('u_eq', state.p.eq);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
};

// =======================================================
// MODULE 2: CPU PROGRESSIVE ENGINE (For True Nebulae)
// =======================================================
class NebulaRenderer {
    constructor(canvasId) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d', {willReadFrequently: true});
        this.hist = null; this.imgData = null;
        this.frames = 0;
    }

    reset() {
        const dpr = window.devicePixelRatio || 1;
        const w = Math.floor(this.cvs.clientWidth * dpr);
        const h = Math.floor(this.cvs.clientHeight * dpr);
        
        if(this.cvs.width !== w || this.cvs.height !== h) {
            this.cvs.width = w; this.cvs.height = h;
            this.hist = new Float32Array(w * h * 3);
            this.imgData = this.ctx.createImageData(w, h);
        }
        if(this.hist) this.hist.fill(0);
        this.frames = 0;
    }

    renderBatch(state, isRight) {
        if(!this.hist) return;
        const w = this.cvs.width; const h = this.cvs.height;
        const cam = isRight ? state.right : state.left;
        
        const vw = (w/h) * (1.0 / cam.z); const vh = 1.0 / cam.z;
        const minX = cam.x - vw/2; const minY = cam.y - vh/2;
        
        const batch = 30000; 
        const p = state.p; const max_i = p.iter;
        const trX = new Float32Array(max_i); const trY = new Float32Array(max_i);

        const isNebulaAtlas = (state.mode === 2 && isRight);
        const grid = p.grid;

        this.frames++;

        for(let i=0; i<batch; i++) {
            let cr, ci, zx, zy, cellX, cellY;
            
            if (isNebulaAtlas) {
                // TRUE NEBULA ATLAS LOGIC
                let asp = w/h;
                let uvX = (Math.random() - 0.5) * asp;
                let uvY = (Math.random() - 0.5); 
                
                cellX = Math.floor(uvX * grid);
                cellY = Math.floor(uvY * grid);
                
                cr = cam.x + (cellX / grid) * (4.0 / cam.z);
                ci = cam.y + (cellY / grid) * (4.0 / cam.z);
                
                zx = (Math.random() - 0.5) * 3.0;
                zy = (Math.random() - 0.5) * 3.0;
                
            } else {
                // STANDARD NEBULA LOGIC
                let sr = cam.x + (Math.random()-0.5) * vw * 1.5;
                let si = cam.y + (Math.random()-0.5) * vh * 1.5;
                
                cr = isRight ? state.c.x : sr;
                ci = isRight ? state.c.y : si;
                zx = isRight ? sr : 0.0;
                zy = isRight ? si : 0.0;
            }
            
            let step = 0; let esc = false;
            
            while(step < max_i) {
                trX[step] = zx; trY[step] = zy;
                let nx, ny;
                if(p.eq === 0) { nx = zx*zx-zy*zy+cr; ny = 2.0*zx*zy+ci; }
                else if(p.eq === 1) { nx = zx*zx*zx - 3.0*zx*zy*zy + cr; ny = 3.0*zx*zx*zy - zy*zy*zy + ci; }
                else if(p.eq === 2) { 
                    let r2=zx*zx+zy*zy; let r4=r2*r2; let r5=r4*Math.sqrt(r2);
                    let a=Math.atan2(zy,zx)*5.0; nx=r5*Math.cos(a)+cr; ny=r5*Math.sin(a)+ci;
                }
                else if(p.eq === 3) { nx = zx*zx-zy*zy+cr; ny = 2.0*Math.abs(zx*zy)+ci; }
                else if(p.eq === 4) { nx = zx*zx-zy*zy+cr; ny = -2.0*zx*zy+ci; }
                
                zx = nx; zy = ny;
                if(zx*zx + zy*zy > 100.0) { esc = true; break; }
                step++;
            }
            
            if(esc && step > 0) {
                for(let s=0; s<step; s++) {
                    let px, py;
                    
                    if (isNebulaAtlas) {
                        let tzX = trX[s] / 3.0; 
                        let tzY = trY[s] / 3.0;
                        if (tzX < -0.5 || tzX > 0.5 || tzY < -0.5 || tzY > 0.5) continue;
                        
                        let guvX = cellX + tzX + 0.5;
                        let guvY = cellY + tzY + 0.5;
                        
                        px = Math.floor((guvX / grid) * h + w/2);
                        py = Math.floor((guvY / grid) * h + h/2);
                        
                    } else {
                        px = Math.floor((trX[s] - minX) / vw * w);
                        py = Math.floor((trY[s] - minY) / vh * h);
                    }
                    
                    if(px>=0 && px<w && py>=0 && py<h) {
                        let idx = ((h - 1 - py) * w + px) * 3; // Invert Y
                        if(step > p.r) this.hist[idx]++; 
                        if(step > p.g) this.hist[idx+1]++; 
                        if(step > p.b) this.hist[idx+2]++; 
                    }
                }
            }
        }
        
        // --- LOGARITHMIC TONE MAPPING ---
        const data = this.imgData.data;
        const len = w * h * 3;
        
        const baseGain = isRight ? 20.0 : 800.0; 
        const scale = (p.den * baseGain) / this.frames;
        const norm = 1.0 / Math.log1p(baseGain); 

        let j=0;
        for(let i=0; i<len; i+=3) {
            let r = Math.log1p(this.hist[i] * scale) * norm;
            let g = Math.log1p(this.hist[i+1] * scale) * norm;
            let b = Math.log1p(this.hist[i+2] * scale) * norm;
            
            data[j++] = Math.min(255, Math.pow(r, 1.2) * 255);
            data[j++] = Math.min(255, Math.pow(g, 1.2) * 255);
            data[j++] = Math.min(255, Math.pow(b, 1.2) * 255);
            data[j++] = 255;
        }
        
        // Grid Lines for Nebula Atlas
        if(isNebulaAtlas) {
            for(let y=0; y<h; y+=h/grid) {
                for(let x=0; x<w; x++) { let idx = (Math.floor(y)*w + x)*4; data[idx]=50; data[idx+1]=50; data[idx+2]=50; }
            }
            for(let x=(w/2)%h; x<w; x+=h/grid) {
                for(let y=0; y<h; y++) { let idx = (y*w + Math.floor(x))*4; data[idx]=50; data[idx+1]=50; data[idx+2]=50; }
            }
        }

        this.ctx.putImageData(this.imgData, 0, 0);
        
        // Draw Dot over Canvas (Left only, not in Atlas)
        if(!isRight && state.mode !== 2) {
            const sx = (state.c.x - cam.x) / vw * w + (w/2);
            const sy = -(state.c.y - cam.y) / vh * h + (h/2); 
            this.ctx.beginPath();
            this.ctx.arc(sx, sy, 5, 0, Math.PI*2);
            this.ctx.fillStyle = 'white'; this.ctx.fill();
            this.ctx.lineWidth = 2; this.ctx.strokeStyle = 'black'; this.ctx.stroke();
        }
    }
}

// =======================================================
// MODULE 3: APP STATE & LOGIC
// =======================================================
const app = {
    state: {
        mode: 0, locked: false, saving: false,
        c: {x: -0.76, y: 0.12},
        left: {x: -0.5, y: 0.0, z: 1.0},
        right: {x: 0.0, y: 0.0, z: 1.0},
        p: { eq: 0, iter: 300, grid: 10, pal: 0, den: 1.5, r: 200, g: 100, b: 50 },
        drag: false, active: null, last: {x:0, y:0}
    },
    glCtx: [], nebCtx: [],

    init: function() {
        this.glCtx = [GL_CORE.setup('gl-left'), GL_CORE.setup('gl-right')];
        this.nebCtx = [new NebulaRenderer('cpu-left'), new NebulaRenderer('cpu-right')];
        ui.init();
        this.triggerReset();
        this.loop();
    },

    triggerReset: function() {
        ui.updParams();
        this.nebCtx[0].reset();
        this.nebCtx[1].reset();
    },

    loop: function() {
        if(!this.state.saving) {
            if(this.state.mode === 0) { 
                GL_CORE.render(this.glCtx[0], this.state, false);
                GL_CORE.render(this.glCtx[1], this.state, true);
            } else if (this.state.mode === 1) {
                this.nebCtx[0].renderBatch(this.state, false);
                this.nebCtx[1].renderBatch(this.state, true);
            } else if (this.state.mode === 2) {
                GL_CORE.render(this.glCtx[0], this.state, false); // Standard Julia Atlas
                this.nebCtx[1].renderBatch(this.state, true);     // True Nebula Atlas
            }
        }
        
        const maxZ = Math.max(this.state.left.z, this.state.right.z);
        document.getElementById('zoom-warning').style.display = (maxZ > 100000 && this.state.mode !== 1) ? 'block' : 'none';
        
        requestAnimationFrame(()=>this.loop());
    },
    
    setMode: function(m) {
        this.state.mode = m;
        
        document.getElementById('app-body').className = m === 1 ? 'mode-nebula' : (m === 2 ? 'mode-atlas' : '');
        document.querySelectorAll('.tab-btn').forEach((b,i)=>b.classList.toggle('active',i===m));
        
        let l="Mandelbrot", r="Julia Set";
        if(m===1) { l="Buddhabrot"; r="Nebula Julia"; }
        if(m===2) { l="Julia Atlas"; r="Nebula Atlas"; } 
        document.getElementById('lbl-left').innerText=l;
        document.getElementById('lbl-right').innerText=r;
        
        // Control Visiblity via explicit JS to prevent CSS bugs
        document.getElementById('cpu-left').style.opacity = (m === 1) ? '1' : '0';
        document.getElementById('cpu-left').style.pointerEvents = (m === 1) ? 'auto' : 'none';
        
        document.getElementById('cpu-right').style.opacity = (m === 1 || m === 2) ? '1' : '0';
        document.getElementById('cpu-right').style.pointerEvents = (m === 1 || m === 2) ? 'auto' : 'none';

        ui.updControls();
        this.triggerReset();
    },

    resetPos: function() {
        this.state.left = {x:-0.5, y:0, z:1};
        this.state.right = {x:0, y:0, z:1};
        this.triggerReset();
    },

    save: function() {
        const view = document.getElementById('save-view').value;
        const resChoice = document.getElementById('save-res').value;
        const isRight = (view === 'right');
        
        const useCpuEngine = (this.state.mode === 1) || (this.state.mode === 2 && isRight);
        
        let targetCvs;
        
        if(useCpuEngine) {
            targetCvs = isRight ? this.nebCtx[1].cvs : this.nebCtx[0].cvs;
        } else {
            this.state.saving = true;
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            const ow = ctx.cvs.width, oh = ctx.cvs.height;
            
            let w = ow, h = oh;
            if(resChoice === '2') { w=1920; h=1080; }
            else if(resChoice === '4') { w=3840; h=2160; }
            else if(resChoice === '8') { w=7680; h=4320; }
            else if(resChoice === 'custom') { 
                w = parseInt(document.getElementById('save-w').value) || 1920;
                h = parseInt(document.getElementById('save-h').value) || 1080;
            }
            
            ctx.cvs.width = w; ctx.cvs.height = h; ctx.gl.viewport(0,0,w,h);
            GL_CORE.render(ctx, this.state, isRight);
            targetCvs = ctx.cvs;
        }
        
        const a = document.createElement('a');
        a.download = `fractal_${view}_${Date.now()}.png`;
        a.href = targetCvs.toDataURL('image/png');
        a.click();
        
        if(!useCpuEngine) {
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            ctx.cvs.width = ctx.cvs.clientWidth * (window.devicePixelRatio||1);
            ctx.cvs.height = ctx.cvs.clientHeight * (window.devicePixelRatio||1);
            this.state.saving = false;
        }
        ui.toggleModal(false);
    }
};

const ui = {
    init: function() {
        this.updParams = () => {
            const v = id => parseFloat(document.getElementById(id).value);
            const p = app.state.p;
            p.eq=v('sel-eq'); p.iter=v('sl-iter'); p.grid=v('sl-grid'); p.r=v('sl-red'); p.g=v('sl-grn'); p.b=v('sl-blu'); p.den=v('sl-den');
            p.pal = parseInt(document.getElementById('sel-pal').value);
            ['iter','grid','red','grn','blu'].forEach(k => document.getElementById(`val-${k}`).innerText = v(`sl-${k}`));
        };
        
        document.querySelectorAll('input[type=range], select').forEach(e => {
            e.addEventListener('input', this.updParams);
            e.addEventListener('change', () => app.triggerReset()); 
        });
        
        document.querySelectorAll('.canvas-container').forEach((cont, idx) => {
            const isR = idx===1;
            
            cont.addEventListener('dblclick', () => {
               app.state.locked = !app.state.locked;
               document.getElementById('lock-indicator').style.display = app.state.locked ? 'block' : 'none';
            });

            cont.addEventListener('mousedown', e => {
                app.state.drag = true;
                app.state.active = isR ? 'r' : 'l';
                app.state.last = {x:e.clientX, y:e.clientY};
                
                if(!isR && app.state.mode!==2 && !app.state.locked) {
                    const r = cont.getBoundingClientRect();
                    const cam = app.state.left;
                    const aspect = cont.clientWidth/cont.clientHeight;
                    const nx = ((e.clientX - r.left) / cont.clientWidth - 0.5) * aspect;
                    const ny = -((e.clientY - r.top) / cont.clientHeight - 0.5); 
                    
                    app.state.c.x = nx / cam.z + cam.x;
                    app.state.c.y = ny / cam.z + cam.y;
                    
                    document.getElementById('c-coords').innerText = `C: ${app.state.c.x.toFixed(4)}, ${app.state.c.y.toFixed(4)}`;
                    if(app.state.mode === 1) app.triggerReset(); 
                }
            });

            cont.addEventListener('mousemove', e => {
                if(app.state.drag && app.state.active === (isR?'r':'l')) {
                    const cam = isR ? app.state.right : app.state.left;
                    const dx = e.clientX - app.state.last.x;
                    const dy = e.clientY - app.state.last.y;
                    app.state.last = {x:e.clientX, y:e.clientY};
                    
                    // FLAWLESS 1:1 PANNING MATH
                    if(app.state.mode === 2) {
                        cam.x -= (dx / cont.clientHeight) * (4.0 / cam.z);
                        cam.y += (dy / cont.clientHeight) * (4.0 / cam.z);
                    } else {
                        cam.x -= (dx / cont.clientHeight) / cam.z;
                        cam.y += (dy / cont.clientHeight) / cam.z;
                    }
                    
                    if(app.state.mode === 1 || app.state.mode === 2) app.triggerReset();
                }
            });

            cont.addEventListener('wheel', e => {
                e.preventDefault();
                const cam = isR ? app.state.right : app.state.left;
                const spd = parseFloat(document.getElementById('sl-zoom').value) * 0.1;
                if(e.deltaY < 0) cam.z *= (1+spd); else cam.z /= (1+spd);
                if(app.state.mode === 1 || app.state.mode === 2) app.triggerReset();
            });
        });
        window.addEventListener('mouseup', () => app.state.drag = false);
    },
    
    toggleModal: function(show) { 
        document.getElementById('save-modal').style.display = show?'flex':'none'; 
        const isNebMode = (app.state.mode === 1) || (app.state.mode === 2 && document.getElementById('save-view').value === 'right');
        document.getElementById('row-res').style.display = isNebMode ? 'none' : 'block';
    },

    checkCustomRes: function() {
        const val = document.getElementById('save-res').value;
        document.getElementById('custom-res-div').style.display = (val === 'custom') ? 'flex' : 'none';
    },
    
    updControls: function() {
        const m = app.state.mode;
        const s = (id, show) => document.getElementById(id).classList.toggle('hidden', !show);
        
        s('grp-neb-r', m===1 || m===2); 
        s('grp-neb-g', m===1 || m===2); 
        s('grp-neb-b', m===1 || m===2); 
        s('grp-neb-den', m===1 || m===2);
        s('grp-pal', m!==1);
        s('grp-grid', m===2);
    }
};

window.onload = () => app.init();
</script>
</body>
</html>
