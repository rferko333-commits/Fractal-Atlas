<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Atlas - Pro</title>
    <style>
        /* UI & LAYOUT STYLES */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --accent: #00d2ff;
            --text: #eee;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-color); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }

        /* HEADER */
        header {
            height: 50px; display: flex; align-items: center; justify-content: space-between;
            padding: 0 15px; border-bottom: 1px solid #333; background: #111;
        }
        #back-btn { background: none; border: none; color: white; font-size: 24px; cursor: pointer; }
        .mode-tabs { display: flex; gap: 10px; }
        .tab-btn {
            background: #222; border: 1px solid #444; color: #888; padding: 6px 12px;
            cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 12px;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* VIEWPORT */
        #viewport {
            display: flex; height: calc(100vh - 200px); width: 100%;
        }
        .canvas-container {
            flex: 1; position: relative; border-right: 1px solid #333; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        
        .view-label {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0,0,0,0.7); padding: 4px 8px; 
            border-radius: 4px; font-size: 12px; pointer-events: none; user-select: none;
        }

        /* CONTROLS */
        #controls {
            height: 150px; background: #080808; border-top: 1px solid #333;
            display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 15px; padding: 15px; align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 11px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type="range"] { width: 100%; cursor: pointer; }
        .val-disp { font-size: 11px; color: var(--accent); float: right; }
        
        /* Colored Labels for Channels */
        .lbl-r { color: #ff6b6b; }
        .lbl-g { color: #51cf66; }
        .lbl-b { color: #339af0; }

        .action-btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 10px; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold;
        }
        .action-btn:hover { background: #555; }

        /* DATA DISPLAY */
        #c-coords {
            position: absolute; bottom: 160px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 5px 10px; font-family: monospace;
            font-size: 12px; border: 1px solid #444; border-radius: 4px; pointer-events: none;
        }

        #error-box {
            display: none; position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: #500; color: #fff; padding: 20px; border: 2px solid #f00; z-index: 999;
            max-width: 80%; font-family: monospace; font-size: 12px; white-space: pre-wrap;
        }

        @media (max-width: 600px) {
            #viewport { flex-direction: column; height: calc(100vh - 180px); }
            .canvas-container { border-right: none; border-bottom: 1px solid #333; }
            #controls { height: 130px; overflow-y: auto; padding-bottom: 30px; }
        }
    </style>
</head>
<body>

<header>
    <!-- The Left Arrow is the Back Button for the Hub -->
    <button id="back-btn" onclick="window.parent.goBack()" title="Back to Menu">&#8592;</button>
    <div class="mode-tabs">
        <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
        <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
        <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
    </div>
    <button class="action-btn" onclick="app.saveImage()">SAVE VIEW</button>
</header>

<div id="error-box"></div>

<div id="viewport">
    <div class="canvas-container" id="container-left">
        <div class="view-label" id="label-left">Mandelbrot</div>
        <canvas id="canvas-left"></canvas>
    </div>
    <div class="canvas-container" id="container-right">
        <div class="view-label" id="label-right">Julia</div>
        <canvas id="canvas-right"></canvas>
    </div>
</div>

<div id="c-coords">C: -0.7600, 0.1200</div>

<div id="controls">
    <!-- Standard Controls -->
    <div class="control-group">
        <label>Total Iterations <span id="val-iter" class="val-disp">300</span></label>
        <input type="range" id="sl-iter" min="50" max="500" value="300">
    </div>

    <div class="control-group">
        <label>Zoom Speed <span id="val-zoom" class="val-disp">1.0</span></label>
        <input type="range" id="sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>

    <!-- Nebula RGB Controls -->
    <div class="control-group">
        <label class="lbl-r">Red Threshold <span id="val-red" class="val-disp">200</span></label>
        <input type="range" id="sl-red" min="0" max="500" value="200">
    </div>
    <div class="control-group">
        <label class="lbl-g">Green Threshold <span id="val-grn" class="val-disp">100</span></label>
        <input type="range" id="sl-grn" min="0" max="500" value="100">
    </div>
    <div class="control-group">
        <label class="lbl-b">Blue Threshold <span id="val-blu" class="val-disp">50</span></label>
        <input type="range" id="sl-blu" min="0" max="500" value="50">
    </div>

    <div class="control-group">
        <label>Brightness / Glow</label>
        <input type="range" id="sl-glow" min="0.5" max="5.0" step="0.1" value="2.0">
    </div>
    
    <button class="action-btn" onclick="app.resetViews()">RESET VIEW</button>
</div>

<!-- SHADERS -->
<script id="vs-source" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
</script>

<script id="fs-source" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 u_res;
    uniform vec2 u_offset;
    uniform float u_zoom;
    uniform vec2 u_c; // Current User Selected C
    
    uniform int u_type;    // 0=Mandel, 1=Julia, 2=AtlasMandel, 3=AtlasJulia
    uniform int u_style;   // 0=Std, 1=Nebula
    uniform int u_show_dot; // 1=Draw the dot, 0=No dot
    
    uniform float u_iter;
    uniform float u_lim_r;
    uniform float u_lim_g;
    uniform float u_lim_b;
    uniform float u_glow;
    uniform float u_grid;

    // Standard Palette
    vec3 palette(float t) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.3, 0.20, 0.20);
        return a + b * cos(6.28318 * (c * t + d));
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec2 z = vec2(0.0);
        vec2 c = vec2(0.0);
        float zoom = u_zoom;
        vec2 offset = u_offset;

        // --- ATLAS LOGIC ---
        if (u_type >= 2) { 
            vec2 grid_uv = uv * u_grid;
            vec2 cell_id = floor(grid_uv);
            uv = fract(grid_uv) - 0.5; 
            vec2 c_map = (cell_id / u_grid) * 3.0; 
            
            if (u_type == 2) { z = uv * 3.0; c = c_map; } 
            else { z = vec2(0.0); c = uv * 3.0 + c_map; }
        } 
        // --- STANDARD LOGIC ---
        else {
            uv = uv / zoom + offset;
            if (u_type == 0) { z = vec2(0.0); c = uv; } 
            else { z = uv; c = u_c; }
        }

        // --- CALCULATION ---
        float iter = 0.0;
        float min_dist = 100.0; // Orbit Trap
        float z_mag = 0.0;
        const int MAX_LOOP = 500;

        for (int i = 0; i < MAX_LOOP; i++) {
            if (float(i) > u_iter) break;

            float x = (z.x * z.x - z.y * z.y) + c.x;
            float y = (2.0 * z.x * z.y) + c.y;
            z = vec2(x, y);
            
            z_mag = dot(z,z);
            if (z_mag > 100.0) break;

            min_dist = min(min_dist, length(z));
            iter += 1.0;
        }

        // --- COLORING ---
        vec3 col = vec3(0.0);

        if (u_style == 1) {
            // --- NEBULA MODE (RGB THRESHOLDS) ---
            // Visual Approximation of the Python "Step > Threshold" logic
            // We use Orbit Trap (min_dist) for the "Structure"
            // We use Iteration Count (iter) for the "Color Masking"

            float brightness = exp(-min_dist * (2.0)); // Base structure
            
            // Mask channels: 1.0 if iter > threshold, else 0.0 (smoothed)
            float r = smoothstep(u_lim_r, u_lim_r + 5.0, iter);
            float g = smoothstep(u_lim_g, u_lim_g + 5.0, iter);
            float b = smoothstep(u_lim_b, u_lim_b + 5.0, iter);

            // Combine
            col = vec3(brightness * r, brightness * g, brightness * b);
            
            // Apply Overall Gain
            col *= u_glow;
        } else {
            // --- STANDARD MODE ---
            if (z_mag < 100.0) {
                col = vec3(0.0);
            } else {
                float sn = iter - log2(log2(dot(z,z))) + 4.0;
                col = palette(sn * 0.05);
            }
        }

        // --- OVERLAYS ---
        
        // 1. Grid Lines (Atlas Only)
        if (u_type >= 2) {
             vec2 guv = abs(fract(gl_FragCoord.xy / u_res.y * u_grid) - 0.5);
             if (guv.x > 0.48 || guv.y > 0.48) col *= 0.5;
        }

        // 2. The Dot (Indicates Selected C)
        // Only draw on Mandelbrot (Type 0) and not in Atlas Mode
        if (u_show_dot == 1 && u_type == 0) {
            // Calculate distance in UV space from current pixel to u_c
            // uv was calculated as: uv / zoom + offset
            // We need to check if current 'c' (the pixel) is close to 'u_c' (the selection)
            float d = distance(c, u_c);
            
            // Dot Size scales with zoom so it remains visible
            float dot_size = 0.015 / zoom; 
            
            if (d < dot_size) {
                col = vec3(1.0); // White Dot
            }
            if (d < dot_size * 1.2 && d > dot_size) {
                col = vec3(0.0); // Black Outline
            }
        }

        gl_FragColor = vec4(col, 1.0);
    }
</script>

<script>
const app = {
    state: {
        mode: 0, 
        c: { x: -0.76, y: 0.12 },
        left: { offset: {x: -0.5, y: 0.0}, zoom: 1.0 },
        right: { offset: {x: 0.0, y: 0.0}, zoom: 1.0 },
        params: { 
            iter: 300, 
            grid: 10, 
            r_lim: 200, g_lim: 100, b_lim: 50, 
            glow: 2.0 
        },
        dragging: false,
        lastMouse: {x:0, y:0},
        activeCanvas: null
    },
    
    contexts: [],

    init: function() {
        this.contexts = [
            this.setupWebGL('canvas-left'),
            this.setupWebGL('canvas-right')
        ];
        if(this.contexts[0] && this.contexts[1]) {
            this.loop();
            this.attachEvents();
        }
    },

    setupWebGL: function(id) {
        const canvas = document.getElementById(id);
        // CRITICAL FIX: preserveDrawingBuffer allows saveImage to work
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || canvas.getContext('experimental-webgl');
        
        if (!gl) { this.showError("WebGL error."); return null; }

        const prog = gl.createProgram();
        const vs = this.compile(gl, 'vs-source', gl.VERTEX_SHADER);
        const fs = this.compile(gl, 'fs-source', gl.FRAGMENT_SHADER);
        if (!vs || !fs) return null;

        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buff = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buff);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        return { gl, prog, canvas };
    },

    compile: function(gl, id, type) {
        const script = document.getElementById(id);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, script.textContent);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            this.showError(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    },

    showError: function(msg) {
        document.getElementById('error-box').style.display = 'block';
        document.getElementById('error-box').innerText = msg;
    },

    render: function(ctxObj, isRight) {
        const { gl, prog, canvas } = ctxObj;
        
        const dpr = window.devicePixelRatio || 1;
        const dispW = Math.floor(canvas.clientWidth * dpr);
        const dispH = Math.floor(canvas.clientHeight * dpr);

        if (canvas.width !== dispW || canvas.height !== dispH) {
            canvas.width = dispW; canvas.height = dispH;
            gl.viewport(0, 0, dispW, dispH);
        }

        const u = (n, v) => {
            const loc = gl.getUniformLocation(prog, n);
            if(typeof v === 'number') gl.uniform1f(loc, v);
            else if(v.length === 2) gl.uniform2f(loc, v[0], v[1]);
        };
        const ui = (n, v) => gl.uniform1i(gl.getUniformLocation(prog, n), v);

        u('u_res', [canvas.width, canvas.height]);
        u('u_c', [this.state.c.x, this.state.c.y]);
        u('u_iter', this.state.params.iter);
        u('u_lim_r', this.state.params.r_lim);
        u('u_lim_g', this.state.params.g_lim);
        u('u_lim_b', this.state.params.b_lim);
        u('u_glow', this.state.params.glow);
        u('u_grid', this.state.params.grid);

        const cam = isRight ? this.state.right : this.state.left;
        u('u_offset', [cam.offset.x, cam.offset.y]);
        u('u_zoom', cam.zoom);

        let type = 0;
        if (this.state.mode === 0 || this.state.mode === 1) type = isRight ? 1 : 0;
        if (this.state.mode === 2) type = isRight ? 1 : 2; 

        ui('u_type', type);
        ui('u_style', this.state.mode === 1 ? 1 : 0);
        
        // Show Dot on Left screen (Mandelbrot) only, and NOT in Atlas mode
        ui('u_show_dot', (!isRight && this.state.mode !== 2) ? 1 : 0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    },

    loop: function() {
        this.render(this.contexts[0], false);
        this.render(this.contexts[1], true);
        requestAnimationFrame(() => this.loop());
    },

    setMode: function(m) {
        this.state.mode = m;
        document.querySelectorAll('.tab-btn').forEach((b, i) => b.classList.toggle('active', i === m));
        const labels = [['Mandelbrot', 'Julia Set'], ['Nebula Mandel', 'Nebula Julia'], ['Julia Atlas', 'Julia Inspector']];
        document.getElementById('label-left').innerText = labels[m][0];
        document.getElementById('label-right').innerText = labels[m][1];
        
        // Show/Hide Grid Control based on mode
        // Note: RGB controls are always shown in this version for simplicity, 
        // but visually they only affect Nebula mode.
    },

    resetViews: function() {
        this.state.left = { offset: {x: -0.5, y: 0.0}, zoom: 1.0 };
        this.state.right = { offset: {x: 0.0, y: 0.0}, zoom: 1.0 };
    },

    saveImage: function() {
        // Save the Right canvas (The Result)
        const link = document.createElement('a');
        link.download = `fractal_view_${Date.now()}.png`;
        link.href = this.contexts[1].canvas.toDataURL('image/png');
        link.click();
    },

    attachEvents: function() {
        const bind = (id, key) => {
            const el = document.getElementById(id);
            if(el) el.oninput = e => {
                this.state.params[key] = parseFloat(e.target.value);
                const disp = document.getElementById(id.replace('sl', 'val'));
                if(disp) disp.innerText = e.target.value;
            };
        };
        bind('sl-iter', 'iter');
        bind('sl-red', 'r_lim');
        bind('sl-grn', 'g_lim');
        bind('sl-blu', 'b_lim');
        bind('sl-glow', 'glow');

        // Mouse Handlers
        [this.contexts[0].canvas, this.contexts[1].canvas].forEach((c, idx) => {
            const isRight = idx === 1;
            
            c.addEventListener('mousedown', e => {
                this.state.dragging = true;
                this.state.activeCanvas = isRight ? 'right' : 'left';
                this.state.lastMouse = { x: e.clientX, y: e.clientY };
                
                if (!isRight && this.state.mode !== 2) {
                    const rect = c.getBoundingClientRect();
                    const cam = this.state.left;
                    // Aspect correction for clicking matches Shader logic
                    const aspect = c.width / c.height; 
                    const normX = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
                    const normY = -((e.clientY - rect.top) / rect.height - 0.5) * 2;
                    
                    const cx = (normX * aspect) / cam.zoom + cam.offset.x;
                    const cy = (normY) / cam.zoom + cam.offset.y;
                    
                    this.state.c = { x: cx, y: cy };
                    document.getElementById('c-coords').innerText = `C: ${cx.toFixed(4)}, ${cy.toFixed(4)}`;
                }
            });

            c.addEventListener('mousemove', e => {
                if (this.state.dragging && this.state.activeCanvas === (isRight?'right':'left')) {
                    const cam = isRight ? this.state.right : this.state.left;
                    const dx = e.clientX - this.state.lastMouse.x;
                    const dy = e.clientY - this.state.lastMouse.y;
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    
                    const factor = 1.0 / (c.clientHeight * cam.zoom); 
                    cam.offset.x -= dx * factor * 2.0; 
                    cam.offset.y += dy * factor * 2.0;
                }
            });

            c.addEventListener('wheel', e => {
                e.preventDefault();
                const cam = isRight ? this.state.right : this.state.left;
                const spd = document.getElementById('sl-zoom').value * 0.1;
                if (e.deltaY < 0) cam.zoom *= (1 + spd);
                else cam.zoom /= (1 + spd);
            });
        });
        window.addEventListener('mouseup', () => this.state.dragging = false);
    }
};

window.onload = () => app.init();
</script>
</body>
</html>
