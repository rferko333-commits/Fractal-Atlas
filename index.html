<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Atlas - Ultimate</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #111;
            --accent: #00d2ff;
            --text: #ddd;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-color); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, Roboto, sans-serif; }

        /* HEADER */
        header {
            height: 40px; display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; border-bottom: 1px solid #333; background: #080808;
        }
        #back-btn { background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0 10px; }
        .mode-tabs { display: flex; gap: 5px; }
        .tab-btn {
            background: #222; border: 1px solid #444; color: #888; padding: 4px 10px;
            cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 11px;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* VIEWPORT */
        #viewport {
            display: flex; height: calc(100vh - 190px); width: 100%;
        }
        .canvas-container {
            flex: 1; position: relative; border-right: 1px solid #333; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        
        .view-label {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0,0,0,0.8); padding: 4px 8px; color: #fff;
            border-radius: 4px; font-size: 12px; pointer-events: none;
        }

        /* CONTROLS */
        #controls {
            height: 150px; background: #080808; border-top: 1px solid #333;
            padding: 10px; overflow-x: auto;
        }
        
        /* Grid Layout for Controls */
        .ctrl-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px; align-items: start;
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 10px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; font-weight: bold; }
        input[type="range"] { width: 100%; cursor: pointer; height: 6px; background: #333; appearance: none; border-radius: 3px; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; }
        select { background: #222; color: #eee; border: 1px solid #444; padding: 4px; border-radius: 4px; font-size: 11px; }

        .val-disp { font-size: 10px; color: var(--accent); float: right; }
        
        /* RGB Specifics */
        .lbl-r { color: #ff6b6b; } .lbl-g { color: #51cf66; } .lbl-b { color: #339af0; }

        /* Hide/Show Logic */
        .hidden { display: none !important; }

        .action-btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px 15px; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold;
            position: absolute; right: 10px; top: 5px;
        }
        .action-btn:hover { background: #555; }

        #c-coords {
            position: absolute; bottom: 160px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 5px 10px; font-family: monospace;
            font-size: 12px; border: 1px solid #444; border-radius: 4px; pointer-events: none;
        }
    </style>
</head>
<body>

<header>
    <button id="back-btn" onclick="window.parent.goBack()">&#8592;</button>
    <div class="mode-tabs">
        <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
        <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
        <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
    </div>
    <div style="width: 40px;"></div> <!-- Spacer -->
    <button class="action-btn" onclick="app.saveImage()">SAVE VIEW</button>
</header>

<div id="viewport">
    <div class="canvas-container">
        <div class="view-label" id="label-left">Mandelbrot</div>
        <canvas id="canvas-left"></canvas>
    </div>
    <div class="canvas-container">
        <div class="view-label" id="label-right">Julia</div>
        <canvas id="canvas-right"></canvas>
    </div>
</div>

<div id="c-coords">C: -0.7600, 0.1200</div>

<div id="controls">
    <div class="ctrl-grid">
        <!-- Universal Controls -->
        <div class="control-group">
            <label>Iterations <span id="val-iter" class="val-disp">300</span></label>
            <input type="range" id="sl-iter" min="50" max="1000" value="300">
        </div>

        <div class="control-group">
            <label>Zoom Speed <span id="val-zoom" class="val-disp">1.0</span></label>
            <input type="range" id="sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <!-- Palette (Only for Fractals/Atlas) -->
        <div class="control-group" id="grp-palette">
            <label>Color Palette</label>
            <select id="sl-palette" onchange="app.updateParams()">
                <option value="0">Magma</option>
                <option value="1">Viridis</option>
                <option value="2">Ice</option>
                <option value="3">Fire</option>
                <option value="4">Psychedelic</option>
            </select>
        </div>

        <!-- Nebula Controls (Only for Nebula) -->
        <div class="control-group hidden" id="grp-neb-density">
            <label>Nebula Density (Points) <span id="val-den" class="val-disp">1.0</span></label>
            <input type="range" id="sl-den" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="control-group hidden" id="grp-neb-rgb">
            <label class="lbl-r">Red Cutoff <span id="val-red" class="val-disp">200</span></label>
            <input type="range" id="sl-red" min="0" max="500" value="200">
            
            <label class="lbl-g">Green Cutoff <span id="val-grn" class="val-disp">100</span></label>
            <input type="range" id="sl-grn" min="0" max="500" value="100">
            
            <label class="lbl-b">Blue Cutoff <span id="val-blu" class="val-disp">50</span></label>
            <input type="range" id="sl-blu" min="0" max="500" value="50">
        </div>

        <!-- Atlas Grid (Only for Atlas) -->
        <div class="control-group hidden" id="grp-atlas">
            <label>Atlas Grid Size <span id="val-grid" class="val-disp">10</span></label>
            <input type="range" id="sl-grid" min="2" max="30" step="1" value="10">
        </div>

        <div class="control-group">
            <label>&nbsp;</label> <!-- Spacer -->
            <button class="action-btn" style="position:static; width:100%" onclick="app.resetViews()">RESET POSITIONS</button>
        </div>
    </div>
</div>

<!-- ================= SHADERS ================= -->

<script id="vs-source" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
</script>

<script id="fs-source" type="x-shader/x-fragment">
    precision highp float;

    // View Uniforms
    uniform vec2 u_res;
    uniform vec2 u_offset;    // Center of the view
    uniform float u_zoom;     // Scale of the view
    uniform vec2 u_c_selected; // The C value picked by user

    // Logic Flags
    uniform int u_is_atlas;   // 1 if Left Screen in Atlas Mode
    uniform int u_is_julia;   // 1 if Right Screen (or Atlas Tiles)
    uniform int u_style;      // 0=Standard, 1=Nebula
    uniform int u_palette;    // Palette ID

    // Params
    uniform float u_iter;
    uniform float u_grid;
    uniform float u_density;  // Simulates "Points" / Brightness
    uniform float u_lim_r;
    uniform float u_lim_g;
    uniform float u_lim_b;

    // --- PALETTE LOGIC ---
    vec3 get_color(float t, int p) {
        vec3 a, b, c, d;
        if (p == 0) { // Magma-ish
            a = vec3(0.5); b = vec3(0.5); c = vec3(1.0); d = vec3(0.3, 0.2, 0.2);
        } else if (p == 1) { // Viridis-ish
            a = vec3(0.5); b = vec3(0.5); c = vec3(1.0); d = vec3(0.0, 0.33, 0.67);
        } else if (p == 2) { // Ice
            a = vec3(0.5); b = vec3(0.5); c = vec3(0.8); d = vec3(0.15, 0.2, 0.3);
        } else if (p == 3) { // Fire
            a = vec3(0.5); b = vec3(0.5); c = vec3(1.0, 1.0, 0.5); d = vec3(0.8, 0.9, 0.3);
        } else { // Psychedelic
            a = vec3(0.5); b = vec3(0.5); c = vec3(2.0); d = vec3(0.5, 0.2, 0.25);
        }
        return a + b * cos(6.28318 * (c * t + d));
    }

    void main() {
        // Base UV (-0.5 to 0.5, corrected for aspect)
        vec2 uv_screen = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;

        vec2 z, c;
        float zoom = u_zoom;
        
        // --- COORDINATE SYSTEM ---
        if (u_is_atlas == 1) {
            // ATLAS MODE LOGIC
            // 1. Grid Logic (Static on screen, unaffected by zoom)
            vec2 uv_grid = uv_screen * u_grid;
            vec2 cell_id = floor(uv_grid); 
            vec2 tile_uv = fract(uv_grid) - 0.5; // Local coords inside tile

            // 2. Map Logic (Determines C for the tile, affected by zoom)
            // Range of C visible: 4.0 / zoom
            float range = 4.0 / zoom;
            
            // This maps the Grid Cell ID (e.g. -5 to 5) to the Complex Plane (e.g. -2 to 2)
            // relative to the current camera offset
            vec2 c_map = u_offset + (cell_id / u_grid) * range;

            z = tile_uv * 3.0; // Zoom out slightly inside the tile
            c = c_map;         // The C value for this tile
        } 
        else {
            // STANDARD / ZOOM MODE
            vec2 world_pos = uv_screen / zoom + u_offset;
            if (u_is_julia == 1) {
                z = world_pos;
                c = u_c_selected;
            } else {
                z = vec2(0.0);
                c = world_pos;
            }
        }

        // --- CALCULATION ---
        float iter = 0.0;
        float min_dist = 100.0;
        float z_mag = 0.0;
        const int MAX_LOOP = 1000;

        for (int i = 0; i < MAX_LOOP; i++) {
            if (float(i) > u_iter) break;

            float x = (z.x * z.x - z.y * z.y) + c.x;
            float y = (2.0 * z.x * z.y) + c.y;
            z = vec2(x, y);
            
            z_mag = dot(z,z);
            if (z_mag > 100.0) break; // Escape

            min_dist = min(min_dist, length(z)); // For Nebula
            iter += 1.0;
        }

        // --- COLORING ---
        vec3 col = vec3(0.0);

        if (u_style == 1) {
            // NEBULA STYLE
            // We use orbit trap distance for structure, and iteration count for RGB cutoffs
            float brightness = exp(-min_dist * (1.5 + u_density)); // Structure
            
            // Apply Thresholds (Hard cutoff smoothed slightly)
            float r = smoothstep(u_lim_r, u_lim_r + 5.0, iter);
            float g = smoothstep(u_lim_g, u_lim_g + 5.0, iter);
            float b = smoothstep(u_lim_b, u_lim_b + 5.0, iter);
            
            // Composition
            col = vec3(brightness * r, brightness * g, brightness * b);
            col *= (u_density * 2.0); // Overall Gain
        } 
        else {
            // FRACTAL STYLE
            if (z_mag < 100.0) {
                col = vec3(0.0);
            } else {
                float sn = iter - log2(log2(dot(z,z))) + 4.0;
                col = get_color(sn * 0.03, u_palette);
            }
        }

        // --- OVERLAYS ---
        // Grid lines for Atlas
        if (u_is_atlas == 1) {
            vec2 guv = abs(fract(gl_FragCoord.xy / u_res.y * u_grid) - 0.5);
            if (guv.x > 0.48 || guv.y > 0.48) col *= 0.2;
        }

        // Dot for Selected C (Only on standard Mandel/Nebula Mandel)
        if (u_is_atlas == 0 && u_is_julia == 0) {
            float d = distance(c, u_c_selected);
            float dot_size = 0.015 / zoom;
            if (d < dot_size) col = vec3(1.0);
            else if (d < dot_size * 1.3) col = vec3(0.0);
        }

        gl_FragColor = vec4(col, 1.0);
    }
</script>

<script>
const app = {
    state: {
        mode: 0, // 0=Frac, 1=Neb, 2=Atlas
        c: { x: -0.76, y: 0.12 },
        left: { offset: {x: -0.5, y: 0.0}, zoom: 1.0 },
        right: { offset: {x: 0.0, y: 0.0}, zoom: 1.0 },
        params: { 
            iter: 300, 
            grid: 10, 
            palette: 0,
            density: 1.0,
            r_lim: 200, g_lim: 100, b_lim: 50
        },
        dragging: false, activeCanvas: null, lastMouse: {x:0,y:0}
    },
    
    contexts: [],

    init: function() {
        this.contexts = [ this.setupWebGL('canvas-left'), this.setupWebGL('canvas-right') ];
        if (this.contexts[0] && this.contexts[1]) {
            this.updateUI();
            this.attachEvents();
            this.loop();
        }
    },

    setupWebGL: function(id) {
        const canvas = document.getElementById(id);
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        if (!gl) return null;

        const prog = gl.createProgram();
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, document.getElementById('vs-source').text);
        gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.getElementById('fs-source').text);
        gl.compileShader(fs);
        
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(fs));
            return null;
        }

        gl.attachShader(prog, vs); gl.attachShader(prog, fs);
        gl.linkProgram(prog); gl.useProgram(prog);

        const buff = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buff);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        return { gl, prog, canvas };
    },

    render: function(ctx, isRight) {
        const { gl, prog, canvas } = ctx;
        
        // Resize
        const dpr = window.devicePixelRatio || 1;
        const w = Math.floor(canvas.clientWidth * dpr), h = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== w || canvas.height !== h) { canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h); }

        // Logic Flags
        // Mode 0: L=Man(Atlas=0, Jul=0, Sty=0) | R=Jul(Atlas=0, Jul=1, Sty=0)
        // Mode 1: L=Man(Atlas=0, Jul=0, Sty=1) | R=Jul(Atlas=0, Jul=1, Sty=1)
        // Mode 2: L=Atl(Atlas=1, Jul=0, Sty=?) | R=Jul(Atlas=0, Jul=1, Sty=?)
        
        // Nebula Style is ON if Mode is 1 OR (Mode is 2 AND we want Nebula Atlas?)
        // Let's assume Atlas Mode (2) is Standard styling unless we add a "Nebula Atlas" mode.
        // For now, Mode 2 is standard style.
        
        let isAtlas = (!isRight && this.state.mode === 2) ? 1 : 0;
        let isJulia = isRight ? 1 : 0;
        let style = (this.state.mode === 1) ? 1 : 0;

        // Special case: If user wants Nebula Atlas, we haven't built a UI for Mode 3 yet, 
        // but the shader supports it. We stick to requirements.

        const u = (n,v) => { const l=gl.getUniformLocation(prog,n); if(typeof v==='number')gl.uniform1f(l,v); else gl.uniform2f(l,v[0],v[1]); };
        const ui = (n,v) => gl.uniform1i(gl.getUniformLocation(prog,n),v);

        u('u_res', [canvas.width, canvas.height]);
        u('u_c_selected', [this.state.c.x, this.state.c.y]);
        u('u_iter', this.state.params.iter);
        u('u_grid', this.state.params.grid);
        u('u_density', this.state.params.density);
        u('u_lim_r', this.state.params.r_lim);
        u('u_lim_g', this.state.params.g_lim);
        u('u_lim_b', this.state.params.b_lim);
        
        ui('u_is_atlas', isAtlas);
        ui('u_is_julia', isJulia);
        ui('u_style', style);
        ui('u_palette', this.state.params.palette);

        const cam = isRight ? this.state.right : this.state.left;
        u('u_offset', [cam.offset.x, cam.offset.y]);
        u('u_zoom', cam.zoom);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    },

    loop: function() {
        this.render(this.contexts[0], false);
        this.render(this.contexts[1], true);
        requestAnimationFrame(() => this.loop());
    },

    setMode: function(m) {
        this.state.mode = m;
        document.querySelectorAll('.tab-btn').forEach((b,i) => b.classList.toggle('active', i===m));
        
        const labels = [['Mandelbrot', 'Julia Set'], ['Nebula Mandel', 'Nebula Julia'], ['Julia Atlas', 'Julia Inspector']];
        document.getElementById('label-left').innerText = labels[m][0];
        document.getElementById('label-right').innerText = labels[m][1];
        
        this.updateUI();
    },

    updateUI: function() {
        // Toggle visibility of controls based on mode
        const show = (id, cond) => document.getElementById(id).classList.toggle('hidden', !cond);
        const m = this.state.mode;

        show('grp-palette', m !== 1); // Show palette if NOT nebula
        show('grp-neb-density', m === 1);
        show('grp-neb-rgb', m === 1);
        show('grp-atlas', m === 2);
    },

    updateParams: function() {
        const val = id => parseFloat(document.getElementById(id).value);
        this.state.params.iter = val('sl-iter');
        this.state.params.grid = val('sl-grid');
        this.state.params.palette = parseInt(document.getElementById('sl-palette').value);
        this.state.params.density = val('sl-den');
        this.state.params.r_lim = val('sl-red');
        this.state.params.g_lim = val('sl-grn');
        this.state.params.b_lim = val('sl-blu');
        
        // Update display text
        const txt = (id, v) => document.getElementById(id).innerText = v;
        txt('val-iter', this.state.params.iter);
        txt('val-grid', this.state.params.grid);
        txt('val-den', this.state.params.density);
        txt('val-red', this.state.params.r_lim);
        txt('val-grn', this.state.params.g_lim);
        txt('val-blu', this.state.params.b_lim);
    },

    resetViews: function() {
        this.state.left = { offset: {x: -0.5, y: 0.0}, zoom: 1.0 };
        this.state.right = { offset: {x: 0.0, y: 0.0}, zoom: 1.0 };
    },

    saveImage: function() {
        const link = document.createElement('a');
        link.download = `fractal_view.png`;
        link.href = this.contexts[1].canvas.toDataURL();
        link.click();
    },

    attachEvents: function() {
        // Sliders
        const inputs = ['sl-iter','sl-grid','sl-den','sl-red','sl-grn','sl-blu','sl-zoom'];
        inputs.forEach(id => document.getElementById(id).oninput = () => this.updateParams());

        // Mouse
        [this.contexts[0].canvas, this.contexts[1].canvas].forEach((c, idx) => {
            const isRight = idx === 1;
            c.addEventListener('mousedown', e => {
                this.state.dragging = true;
                this.state.activeCanvas = isRight ? 'right' : 'left';
                this.state.lastMouse = { x: e.clientX, y: e.clientY };

                // Picking C (Only on Left Screen, Not in Atlas Mode)
                if (!isRight && this.state.mode !== 2) {
                    const r = c.getBoundingClientRect();
                    const cam = this.state.left;
                    const asp = c.width/c.height;
                    const nx = ((e.clientX-r.left)/r.width - 0.5)*2;
                    const ny = -((e.clientY-r.top)/r.height - 0.5)*2;
                    
                    const cx = (nx * asp) / cam.zoom + cam.offset.x;
                    const cy = ny / cam.zoom + cam.offset.y;
                    this.state.c = { x: cx, y: cy };
                    document.getElementById('c-coords').innerText = `C: ${cx.toFixed(4)}, ${cy.toFixed(4)}`;
                }
            });

            c.addEventListener('mousemove', e => {
                if(this.state.dragging && this.state.activeCanvas === (isRight?'right':'left')) {
                    const cam = isRight ? this.state.right : this.state.left;
                    const dx = e.clientX - this.state.lastMouse.x;
                    const dy = e.clientY - this.state.lastMouse.y;
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    
                    const factor = 2.0 / (c.clientHeight * cam.zoom);
                    cam.offset.x -= dx * factor;
                    cam.offset.y += dy * factor;
                }
            });

            c.addEventListener('wheel', e => {
                e.preventDefault();
                const cam = isRight ? this.state.right : this.state.left;
                const spd = parseFloat(document.getElementById('sl-zoom').value) * 0.1;
                if (e.deltaY < 0) cam.zoom *= (1 + spd); else cam.zoom /= (1 + spd);
            });
        });
        window.addEventListener('mouseup', () => this.state.dragging = false);
    }
};

window.onload = () => app.init();
</script>
</body>
</html>
