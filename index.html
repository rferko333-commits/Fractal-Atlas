<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Atlas (Fixed)</title>
    <style>
        /* UI & LAYOUT STYLES */
        :root {
            --bg-color: #000;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --accent: #00d2ff;
            --text: #eee;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-color); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }

        /* HEADER */
        header {
            height: 50px; display: flex; align-items: center; justify-content: space-between;
            padding: 0 15px; border-bottom: 1px solid #333; background: #111;
        }
        #back-btn { background: none; border: none; color: white; font-size: 24px; cursor: pointer; }
        .mode-tabs { display: flex; gap: 10px; }
        .tab-btn {
            background: #222; border: 1px solid #444; color: #888; padding: 6px 12px;
            cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 12px;
        }
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* VIEWPORT */
        #viewport {
            display: flex; height: calc(100vh - 200px); width: 100%;
        }
        .canvas-container {
            flex: 1; position: relative; border-right: 1px solid #333; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        
        .view-label {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0,0,0,0.7); padding: 4px 8px; 
            border-radius: 4px; font-size: 12px; pointer-events: none; user-select: none;
        }

        /* CONTROLS */
        #controls {
            height: 150px; background: #080808; border-top: 1px solid #333;
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px; padding: 15px; align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 11px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type="range"] { width: 100%; cursor: pointer; }
        .val-disp { font-size: 11px; color: var(--accent); float: right; }
        
        .action-btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 10px; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold;
        }
        .action-btn:hover { background: #555; }

        /* DATA DISPLAY */
        #c-coords {
            position: absolute; bottom: 160px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 5px 10px; font-family: monospace;
            font-size: 12px; border: 1px solid #444; border-radius: 4px; pointer-events: none;
        }

        /* ERROR BOX (Hidden unless broken) */
        #error-box {
            display: none; position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: #500; color: #fff; padding: 20px; border: 2px solid #f00; z-index: 999;
            max-width: 80%; font-family: monospace; font-size: 12px; white-space: pre-wrap;
        }

        @media (max-width: 600px) {
            #viewport { flex-direction: column; height: calc(100vh - 180px); }
            .canvas-container { border-right: none; border-bottom: 1px solid #333; }
            #controls { height: 130px; overflow-y: auto; padding-bottom: 30px; }
        }
    </style>
</head>
<body>

<header>
    <button id="back-btn" onclick="window.parent.goBack()">&#8592;</button>
    <div class="mode-tabs">
        <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
        <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
        <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
    </div>
    <button class="action-btn" onclick="app.saveImage()">SAVE VIEW</button>
</header>

<div id="error-box"></div>

<div id="viewport">
    <div class="canvas-container" id="container-left">
        <div class="view-label" id="label-left">Mandelbrot</div>
        <canvas id="canvas-left"></canvas>
    </div>
    <div class="canvas-container" id="container-right">
        <div class="view-label" id="label-right">Julia</div>
        <canvas id="canvas-right"></canvas>
    </div>
</div>

<div id="c-coords">C: -0.7600, 0.1200</div>

<div id="controls">
    <div class="control-group">
        <label>Iterations <span id="val-iter" class="val-disp">100</span></label>
        <input type="range" id="sl-iter" min="20" max="500" value="100">
    </div>

    <div class="control-group">
        <label>Zoom Speed <span id="val-zoom" class="val-disp">1.0</span></label>
        <input type="range" id="sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
    </div>

    <div class="control-group">
        <label>Atlas Grid <span id="val-grid" class="val-disp">10</span></label>
        <input type="range" id="sl-grid" min="2" max="50" step="1" value="10">
    </div>

    <div class="control-group">
        <label>Color Shift</label>
        <input type="range" id="sl-color" min="0" max="1" step="0.01" value="0.5">
    </div>

    <div class="control-group">
        <label>Glow (Nebula)</label>
        <input type="range" id="sl-glow" min="0.1" max="3.0" step="0.1" value="1.2">
    </div>
    
    <button class="action-btn" onclick="app.resetViews()">RESET VIEW</button>
</div>

<!-- ========================================== -->
<!--            VERTEX SHADER                   -->
<!-- ========================================== -->
<script id="vs-source" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>

<!-- ========================================== -->
<!--           FRAGMENT SHADER                  -->
<!-- ========================================== -->
<script id="fs-source" type="x-shader/x-fragment">
    precision highp float;

    // Uniforms passed from JS
    uniform vec2 u_res;
    uniform vec2 u_offset;
    uniform float u_zoom;
    uniform vec2 u_c;
    
    uniform int u_type;    // 0=Mandel, 1=Julia, 2=AtlasMandel, 3=AtlasJulia
    uniform int u_style;   // 0=Std, 1=Nebula
    
    uniform float u_iter;
    uniform float u_color;
    uniform float u_glow;
    uniform float u_grid;

    // Palette Function
    vec3 palette(float t) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.3, 0.20, 0.20);
        return a + b * cos(6.28318 * (c * t * u_color + d));
    }

    void main() {
        // Fix aspect ratio
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec2 z = vec2(0.0);
        vec2 c = vec2(0.0);
        float zoom = u_zoom;
        
        // --- LOGIC SPLIT FOR MODES ---
        
        if (u_type >= 2) { 
            // ATLAS MODE
            vec2 grid_uv = uv * u_grid;
            vec2 cell_id = floor(grid_uv);
            
            // Local UV inside the tiny tile
            uv = fract(grid_uv) - 0.5; 
            
            // Calculate C based on tile position
            vec2 c_map = (cell_id / u_grid) * 3.0; // Map grid to complex plane
            
            if (u_type == 2) {
                z = uv * 3.0; // Show Julia
                c = c_map;    // Use Grid as C
            } else {
                // Rare case
                z = vec2(0.0);
                c = uv * 3.0 + c_map;
            }
        } else {
            // STANDARD MODE
            uv = uv / zoom + u_offset;
            
            if (u_type == 0) {
                // Mandelbrot
                z = vec2(0.0);
                c = uv;
            } else {
                // Julia
                z = uv;
                c = u_c;
            }
        }

        // --- FRACTAL LOOP ---
        // CRITICAL FIX: Loop limit must be constant integer for WebGL 1.0 compatibility
        float iter = 0.0;
        float min_dist = 100.0;
        float z_mag = 0.0;
        
        const int MAX_LOOP = 500; // Hard limit for shader compilation

        for (int i = 0; i < MAX_LOOP; i++) {
            // Dynamic break based on user slider
            if (float(i) > u_iter) break;

            float x = (z.x * z.x - z.y * z.y) + c.x;
            float y = (2.0 * z.x * z.y) + c.y;
            z = vec2(x, y);
            
            z_mag = dot(z,z);
            if (z_mag > 100.0) break;

            min_dist = min(min_dist, length(z));
            iter += 1.0;
        }

        // --- COLORING ---
        vec3 col = vec3(0.0);

        if (u_style == 1) {
            // NEBULA STYLE
            float glow = exp(-min_dist * u_glow);
            float outer = iter / u_iter;
            
            if (z_mag < 100.0) {
                col = vec3(glow * 0.8, glow * 0.9, glow * 1.0);
            } else {
                col = vec3(0.0, outer * 0.2, outer * 0.4);
            }
        } else {
            // STANDARD STYLE
            if (z_mag < 100.0) {
                col = vec3(0.0);
            } else {
                float sn = iter - log2(log2(dot(z,z))) + 4.0;
                col = palette(sn * 0.05);
            }
        }

        // Draw Grid Lines in Atlas Mode
        if (u_type >= 2) {
             vec2 guv = abs(fract(gl_FragCoord.xy / u_res.y * u_grid) - 0.5);
             if (guv.x > 0.48 || guv.y > 0.48) col *= 0.5;
        }

        gl_FragColor = vec4(col, 1.0);
    }
</script>


<!-- ========================================== -->
<!--              JAVASCRIPT                    -->
<!-- ========================================== -->
<script>
const app = {
    state: {
        mode: 0, 
        c: { x: -0.76, y: 0.12 },
        left: { offset: {x: -0.5, y: 0.0}, zoom: 1.0 },
        right: { offset: {x: 0.0, y: 0.0}, zoom: 1.0 },
        params: { iter: 100, grid: 10, color: 0.5, glow: 1.2 },
        dragging: false,
        lastMouse: {x:0, y:0},
        activeCanvas: null
    },
    
    contexts: [], // Stores [ctxLeft, ctxRight]

    init: function() {
        this.contexts = [
            this.setupWebGL('canvas-left'),
            this.setupWebGL('canvas-right')
        ];

        // Start Loop
        if(this.contexts[0] && this.contexts[1]) {
            this.loop();
            this.attachEvents();
        }
    },

    setupWebGL: function(id) {
        const canvas = document.getElementById(id);
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            this.showError("WebGL not supported on this browser.");
            return null;
        }

        // Create Program
        const prog = gl.createProgram();
        const vs = this.compile(gl, 'vs-source', gl.VERTEX_SHADER);
        const fs = this.compile(gl, 'fs-source', gl.FRAGMENT_SHADER);
        
        if (!vs || !fs) return null; // Error handled in compile

        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        gl.useProgram(prog);

        // Buffer
        const buff = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buff);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        return { gl, prog, canvas, id };
    },

    compile: function(gl, id, type) {
        const script = document.getElementById(id);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, script.textContent);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            this.showError("Shader Compile Error:\n" + gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    },

    showError: function(msg) {
        const box = document.getElementById('error-box');
        box.style.display = 'block';
        box.innerText = msg;
        console.error(msg);
    },

    render: function(ctxObj, isRight) {
        const { gl, prog, canvas } = ctxObj;
        
        // Resize Handling
        const dpr = window.devicePixelRatio || 1;
        const dispW = Math.floor(canvas.clientWidth * dpr);
        const dispH = Math.floor(canvas.clientHeight * dpr);

        if (canvas.width !== dispW || canvas.height !== dispH) {
            canvas.width = dispW;
            canvas.height = dispH;
            gl.viewport(0, 0, dispW, dispH);
        }

        // Uniform Helpers
        const u = (n, v) => {
            const loc = gl.getUniformLocation(prog, n);
            if(typeof v === 'number') gl.uniform1f(loc, v);
            else if(v.length === 2) gl.uniform2f(loc, v[0], v[1]);
        };
        const ui = (n, v) => gl.uniform1i(gl.getUniformLocation(prog, n), v);

        // Pass State
        u('u_res', [canvas.width, canvas.height]);
        u('u_c', [this.state.c.x, this.state.c.y]);
        u('u_iter', this.state.params.iter);
        u('u_color', this.state.params.color);
        u('u_glow', this.state.params.glow);
        u('u_grid', this.state.params.grid);

        // View logic
        const cam = isRight ? this.state.right : this.state.left;
        u('u_offset', [cam.offset.x, cam.offset.y]);
        u('u_zoom', cam.zoom);

        // Mode Logic
        // Mode 0: M / J
        // Mode 1: M / J (Nebula)
        // Mode 2: Atlas / J
        let type = 0;
        if (this.state.mode === 0 || this.state.mode === 1) type = isRight ? 1 : 0;
        if (this.state.mode === 2) type = isRight ? 1 : 2; 

        ui('u_type', type);
        ui('u_style', this.state.mode === 1 ? 1 : 0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    },

    loop: function() {
        this.render(this.contexts[0], false);
        this.render(this.contexts[1], true);
        requestAnimationFrame(() => this.loop());
    },

    // --- INTERACTION ---
    setMode: function(m) {
        this.state.mode = m;
        document.querySelectorAll('.tab-btn').forEach((b, i) => b.classList.toggle('active', i === m));
        const labels = [['Mandelbrot', 'Julia Set'], ['Nebula Mandel', 'Nebula Julia'], ['Julia Atlas', 'Julia Inspector']];
        document.getElementById('label-left').innerText = labels[m][0];
        document.getElementById('label-right').innerText = labels[m][1];
    },

    resetViews: function() {
        this.state.left = { offset: {x: -0.5, y: 0.0}, zoom: 1.0 };
        this.state.right = { offset: {x: 0.0, y: 0.0}, zoom: 1.0 };
    },

    saveImage: function() {
        // Save the Right canvas
        const link = document.createElement('a');
        link.download = `fractal_${Date.now()}.png`;
        link.href = this.contexts[1].canvas.toDataURL();
        link.click();
    },

    attachEvents: function() {
        const updateVal = (id, key) => {
            const el = document.getElementById(id);
            el.oninput = e => {
                this.state.params[key] = parseFloat(e.target.value);
                const disp = document.getElementById(id.replace('sl', 'val'));
                if(disp) disp.innerText = e.target.value;
            };
        };
        updateVal('sl-iter', 'iter');
        updateVal('sl-zoom', 'zoom_speed'); // Dummy
        updateVal('sl-grid', 'grid');
        updateVal('sl-color', 'color');
        updateVal('sl-glow', 'glow');

        // Mouse Handlers
        [this.contexts[0].canvas, this.contexts[1].canvas].forEach((c, idx) => {
            const isRight = idx === 1;
            
            c.addEventListener('mousedown', e => {
                this.state.dragging = true;
                this.state.activeCanvas = isRight ? 'right' : 'left';
                this.state.lastMouse = { x: e.clientX, y: e.clientY };
                
                // Set C on Left Click
                if (!isRight && this.state.mode !== 2) {
                    const rect = c.getBoundingClientRect();
                    const cam = this.state.left;
                    // Fix aspect ratio calculation for correct clicking
                    const aspect = c.width / c.height; 
                    const normX = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
                    const normY = -((e.clientY - rect.top) / rect.height - 0.5) * 2;
                    
                    // Aspect ratio correction is key here
                    // In shader: uv = (coord - 0.5*res) / res.y
                    // So X is multiplied by aspect ratio implicitly in shader coordinates
                    const cx = (normX * (rect.width/rect.height)) / cam.zoom + cam.offset.x;
                    const cy = (normY) / cam.zoom + cam.offset.y;
                    
                    this.state.c = { x: cx, y: cy };
                    document.getElementById('c-coords').innerText = `C: ${cx.toFixed(4)}, ${cy.toFixed(4)}`;
                }
            });

            c.addEventListener('mousemove', e => {
                if (this.state.dragging && this.state.activeCanvas === (isRight?'right':'left')) {
                    const cam = isRight ? this.state.right : this.state.left;
                    const dx = e.clientX - this.state.lastMouse.x;
                    const dy = e.clientY - this.state.lastMouse.y;
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    
                    // Pan Speed
                    const factor = 1.0 / (c.clientHeight * cam.zoom); 
                    cam.offset.x -= dx * factor * 2.0; // 2.0 to match aspect correction roughly
                    cam.offset.y += dy * factor * 2.0;
                }
            });

            c.addEventListener('wheel', e => {
                e.preventDefault();
                const cam = isRight ? this.state.right : this.state.left;
                const spd = document.getElementById('sl-zoom').value * 0.1;
                if (e.deltaY < 0) cam.zoom *= (1 + spd);
                else cam.zoom /= (1 + spd);
            });
        });
        
        window.addEventListener('mouseup', () => this.state.dragging = false);
    }
};

// Start
window.onload = () => app.init();
</script>
</body>
</html>
